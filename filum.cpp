#include "filum.h"

//=========================================================================================================
//перераспределить нагрузки потоков для нового количества существ
//=========================================================================================================
void FILA::realloca(OECOSYS* _nc)
{
	nc = _nc;
	nsec_init = 0;
	et.restart();
	for(int i=0;i<fila.size();i++)
	{
		fila[i]->p = this;
		fila[i]->n1 = i*nc->n()/fila.size();
		fila[i]->n2 = (i+1)*nc->n()/fila.size();
	}
}

//=========================================================================================================
// запусить все потоки
//=========================================================================================================
void FILA::lancea()
{
	nprocs = 0;
	for(int i=0;i<fila.size();i++)
		fila[i]->start();
}

//=========================================================================================================
//возобновить
//=========================================================================================================
void FILA::resume()
{
//	if(fila.size()>0)
	{
		nprocs = 0;
		et.restart();
		nc->presync(et.nsecsElapsed());
		syncpause.lock();
		nc->resume();
		syncpause.unlock();
		wc.wakeAll();
	}
}

//=========================================================================================================
//приостановить
//=========================================================================================================
void FILA::pause()
{
// 	if(fila.size()>0)
	{
		//сохранить долготу последнего сеанса
		nsec_init += et.nsecsElapsed();
		syncpause.lock();
		nc->cessa();
		syncpause.unlock();
	}
}

//=========================================================================================================
// конструктор
//=========================================================================================================
FILA::FILA(OECOSYS*_nc, int nfila, int tisync) : nc(_nc), tsync(tisync), nsec_init(0)
{
	if(nfila>0)
	{
		//подготовить память
		fila.resize(nfila);
		for(int i=0;i<nfila;i++) fila[i] = new FILUM;

		//распределить участки работы
		realloca(nc);

		//если синхронный режим
		if(tsync)
		{
			connect(&timer, &QTimer::timeout, this, &FILA::synchro);
			timer.start(tsync);
		}
	}
}

//=========================================================================================================
// деструктор
//=========================================================================================================
FILA::~FILA()
{ 
	for(int i=0; i<fila.size(); i++)
	{
		fila[i]->terminate();
		delete fila[i];
	}
}


void FILUM::run()
{ 
	while(p->nc) 
	{
		//рассмотрение возможности остановки при внешней паузе
		p->syncpause.lock();
		if(!p->nc->in_actione()) p->wc.wait(&p->syncpause); 
		p->syncpause.unlock();
				
		p->syncproc.lock();
		p->nprocs++;
		p->syncproc.unlock();

		//выполнение над текущим лоскутом
		p->nc->mod_ra(n1, n2);

		//ожидание последнего и подведение итогов всех потоков - рассчёт номера итерации, времени
		p->syncproc.lock();
		p->nprocs--;
		if(p->nprocs != 0)
			p->ws.wait(&p->syncproc);
		else
		{
			//подождать внешнего тика, чтобы продолжить
			if(p->tsync)
			{
				p->syncti.lock();
				p->wt.wait(&p->syncti);
				p->syncti.unlock();
			}

			//структурные изменения в экосистеме - только последовательно для всех сразу
			p->nc->mod_s();

			//дождаться, пока пройдёт достаточное время, прежде чем дельта станет удобоваримой
			while(!p->nc->synchro_post ( p->et.nsecsElapsed() ));

			//началь новый цикл
			p->ws.wakeAll();
		}
		p->syncproc.unlock();
	}
}
